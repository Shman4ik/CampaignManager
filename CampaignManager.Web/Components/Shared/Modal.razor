@namespace CampaignManager.Web.Components.Shared
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<!-- Modal backdrop with accessibility support -->
<div class="@(IsVisible ? "fixed inset-0 z-50 overflow-auto bg-black/30 flex justify-center items-start pt-10 sm:pt-20 px-4 animate-fadeIn" : "hidden")"
     @onclick="HandleBackdropClick"
     @onkeydown="HandleKeyDown"
     role="dialog"
     aria-modal="true"
     aria-labelledby="modal-title"
     tabindex="-1">

    <!-- Modal container with stop propagation -->
    <div class="bg-white rounded-2xl shadow-2xl overflow-hidden w-full @MaxWidthClass @(IsVisible ? "animate-scaleIn" : "") transform transition-all duration-200"
         @onclick:stopPropagation="true">

        <!-- Header -->
        <div class="p-6 border-b border-gray-200 @HeaderBgClass text-white flex justify-between items-center">
            <h3 id="modal-title" class="font-bold text-xl sm:text-2xl">@Title</h3>
            <button @onclick="OnClose"
                    @ref="closeButtonRef"
                    type="button"
                    aria-label="Закрыть диалог"
                    class="min-w-[44px] min-h-[44px] flex items-center justify-center text-white hover:bg-opacity-80 rounded-lg transition-all duration-200 active:bg-opacity-90 focus:outline-none focus:ring-2 focus:ring-white/50">
                <i class="fas fa-times text-xl"></i>
            </button>
        </div>

        <!-- Body -->
        <div class="p-6 sm:p-8 bg-white @(MaxHeight != null ? $"max-h-[{MaxHeight}] overflow-y-auto" : "")">
            @ChildContent
        </div>

        <!-- Footer -->
        @if (FooterContent != null)
        {
            <div class="p-6 border-t border-gray-200 flex flex-col sm:flex-row justify-end gap-3 bg-gray-50">
                @FooterContent
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public string Title { get; set; } = string.Empty;
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public RenderFragment? FooterContent { get; set; }
    [Parameter] public string MaxWidth { get; set; } = "4xl"; // sm, md, lg, xl, 2xl, 3xl, 4xl, 5xl, 6xl, 7xl
    [Parameter] public string? MaxHeight { get; set; } = "70vh";
    [Parameter] public string HeaderColorScheme { get; set; } = "primary"; // primary, red, blue, green, etc.

    /// <summary>
    /// Allow closing modal by clicking outside
    /// </summary>
    [Parameter] public bool CloseOnBackdropClick { get; set; } = true;

    private ElementReference closeButtonRef;
    private IJSObjectReference? jsModule;
    private DotNetObjectReference<Modal>? dotNetRef;
    private bool wasVisible = false;

    private string MaxWidthClass => $"max-w-{MaxWidth}";

    private string HeaderBgClass => HeaderColorScheme.ToLower() switch
    {
        "red" => "bg-error-600",
        "error" => "bg-error-600",
        "blue" => "bg-accent-600",
        "info" => "bg-accent-600",
        "green" => "bg-success-600",
        "success" => "bg-success-600",
        "primary" => "bg-primary-700",
        "secondary" => "bg-secondary-600",
        "accent" => "bg-accent-600",
        _ => "bg-primary-700"
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import",
                "./Components/Shared/Modal.razor.js");
            dotNetRef = DotNetObjectReference.Create(this);
        }

        // Only focus close button when modal is first opened (not on every re-render)
        if (IsVisible && !wasVisible && jsModule != null)
        {
            // Focus the close button when modal opens
            await jsModule.InvokeVoidAsync("focusElement", closeButtonRef);
            // Prevent body scroll
            await jsModule.InvokeVoidAsync("preventBodyScroll", true);
            wasVisible = true;
        }
        else if (!IsVisible && wasVisible && jsModule != null)
        {
            // Restore body scroll when modal closes
            await jsModule.InvokeVoidAsync("preventBodyScroll", false);
            wasVisible = false;
        }
    }

    private void HandleBackdropClick()
    {
        if (CloseOnBackdropClick)
        {
            OnClose.InvokeAsync();
        }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape" && CloseOnBackdropClick)
        {
            OnClose.InvokeAsync();
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (jsModule is not null)
            {
                // Best-effort cleanup; safe when circuit is still connected
                await jsModule.InvokeVoidAsync("preventBodyScroll", false);
                await jsModule.DisposeAsync();
            }
        }
        catch (JSDisconnectedException) { /* circuit is gone — ignore */ }
        catch (ObjectDisposedException) { }
        catch (TaskCanceledException) { }
        finally
        {
            dotNetRef?.Dispose();
        }
    }
}
