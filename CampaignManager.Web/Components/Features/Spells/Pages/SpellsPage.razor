@page "/spells"
@using CampaignManager.Web.Components.Features.Spells.Components
@using CampaignManager.Web.Components.Features.Spells.Model
@using CampaignManager.Web.Components.Features.Spells.Services
@using CampaignManager.Web.Components.Shared
@attribute [Authorize]
@inject SpellService SpellService
@inject ILogger<SpellsPage> Logger
@rendermode InteractiveServer

<PageTitle>Заклинания - Campaign Manager</PageTitle>

<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 font-sans">
    <FilterPanel Title="Фильтры" @bind-IsExpanded="isSearchPanelVisible">
        <ActionButtons>
            @if (isSearchPanelVisible)
            {
                <button @onclick="ResetFilters"
                        class="min-h-[44px] lg:w-64 px-4 py-3 text-primary-600 hover:text-primary-800 bg-primary-50 hover:bg-primary-100 rounded-lg border border-primary-200 hover:border-primary-300 text-base font-medium flex items-center justify-center gap-2 transition-all duration-200">
                    <i class="fas fa-undo-alt"></i>
                    <span class="hidden sm:inline">Сбросить</span>
                </button>
            }
            <button @onclick="ShowAddModal"
                    class="min-h-[44px] lg:w-64 px-4 py-3 bg-gradient-to-r from-primary-600 to-primary-700 hover:from-primary-700 hover:to-primary-800 text-white font-semibold rounded-lg text-base flex items-center justify-center gap-2 shadow-md hover:shadow-lg transition-all duration-200">
                <i class="fas fa-plus"></i>
                <span>Добавить</span>
            </button>
        </ActionButtons>
        <ChildContent>
            <SpellsFilterControls
                SearchQuery="@searchQuery"
                SearchQueryChanged="@((string value) => { searchQuery = value; ApplyFilters(); })"
                SelectedTypeFilter="@selectedTypeFilter"
                SelectedTypeFilterChanged="@((string? value) => { selectedTypeFilter = value; ApplyFilters(); })"
                SpellTypes="@SpellTypes"
                OnFiltersChanged="ApplyFilters" />
        </ChildContent>
    </FilterPanel>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <Alert Type="error" Title="Ошибка">
            @errorMessage
        </Alert>
    }

    @if (!paginatedSpells.Any())
    {
        <EmptyState
            Title="Заклинания не найдены"
            Message="Попробуйте изменить параметры фильтра или добавить новое заклинание."
            IconClass="fa-hat-wizard">
            <ActionButton>
                <button @onclick="ShowAddModal"
                        class="min-h-[44px] px-5 py-3 bg-primary-600 hover:bg-primary-700 text-white rounded-lg text-base font-semibold shadow-md transition-all duration-200">
                    Добавить заклинание
                </button>
            </ActionButton>
        </EmptyState>
    }
    else
    {
        <SpellsListView
            Spells="@paginatedSpells"
            ExpandedSpellId="@expandedSpellId"
            CurrentSortField="@sortField"
            SortAscending="@sortAscending"
            OnSortChanged="ToggleSort"
            OnEdit="ShowEditModal"
            OnDelete="ShowDeleteModal"
            OnToggleExpand="@((Spell spell) => ToggleSpellDetails(spell))" />

        <Pagination
            CurrentPage="@currentPage"
            TotalPages="@totalPages"
            TotalItems="@filteredSpells.Count()"
            ItemsPerPage="@spellsPerPage"
            ItemsLabel="заклинаний"
            OnPageChanged="GoToPage" />
    }

    <Modal IsVisible="@showModal"
           OnClose="HideModal"
           Title="@(isEditMode ? "Редактировать заклинание" : "Добавить заклинание")"
           MaxWidth="4xl"
           HeaderColorScheme="primary">
        <ChildContent>
            @if (!string.IsNullOrEmpty(modalErrorMessage))
            {
                <Alert Type="error" class="mb-6">
                    @modalErrorMessage
                </Alert>
            }
            <SpellFormFields
                Spell="@editSpell"
                SpellTypes="@SpellTypes"
                OnValidSubmit="HandleValidSubmit"
                FormId="spell-edit-form" />
        </ChildContent>
        <FooterContent>
            <button type="button"
                    class="min-h-[44px] px-6 py-3 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 active:bg-gray-400 transition-all duration-200 shadow-sm font-semibold text-base"
                    @onclick="HideModal">
                Отмена
            </button>
            <button type="submit" form="spell-edit-form"
                    class="min-h-[44px] px-6 py-3 bg-gradient-to-r from-primary-600 to-primary-700 text-white rounded-lg hover:from-primary-700 hover:to-primary-800 active:from-primary-800 active:to-primary-900 transition-all duration-200 shadow-md hover:shadow-lg font-semibold text-base">
                Сохранить
            </button>
        </FooterContent>
    </Modal>

    <ConfirmationModal
        IsVisible="@showDeleteModal"
        OnConfirm="ConfirmDelete"
        OnCancel="HideDeleteModal"
        Title="Подтверждение удаления"
        Message="Вы уверены, что хотите удалить это заклинание?"
        ConfirmText="Удалить"
        CancelText="Отмена"
        IconType="warning">
        <DetailsContent>
            <p class="text-gray-700 text-base">
                <span class="font-semibold text-gray-900">Название:</span> @(deleteSpell?.Name)
            </p>
            <p class="text-gray-700 text-base">
                <span class="font-semibold text-gray-900">Тип:</span> @(deleteSpell?.SpellType)
            </p>
        </DetailsContent>
    </ConfirmationModal>
</div>

@code {
    private readonly int spellsPerPage = 20;

    private bool isSearchPanelVisible = true;
    private bool showModal;
    private bool showDeleteModal;
    private bool isEditMode;

    private List<Spell>? spells;
    private string searchQuery = string.Empty;
    private string? selectedTypeFilter;

    private Spell editSpell = new() { Name = string.Empty, SpellType = string.Empty };
    private Spell? deleteSpell;
    private Guid? expandedSpellId;

    private string? errorMessage;
    private string? modalErrorMessage;

    private int currentPage = 1;
    private int totalPages => Math.Max(1, (int)Math.Ceiling(filteredSpells.Count() / (double)spellsPerPage));
    private string? sortField;
    private bool sortAscending = true;

    private IQueryable<Spell> filteredSpells => FilterSpells();
    private IEnumerable<Spell> paginatedSpells => filteredSpells
        .Skip((currentPage - 1) * spellsPerPage)
        .Take(spellsPerPage)
        .ToList();

    private IEnumerable<string> SpellTypes => spells?
        .Where(spell => !string.IsNullOrWhiteSpace(spell.SpellType))
        .Select(spell => spell.SpellType.Trim())
        .Distinct(StringComparer.OrdinalIgnoreCase)
        .OrderBy(type => type, StringComparer.OrdinalIgnoreCase)
        ?? Enumerable.Empty<string>();

    protected override async Task OnInitializedAsync()
    {
        await LoadSpellsAsync();
    }

    private async Task LoadSpellsAsync()
    {
        errorMessage = null;
        try
        {
            spells = await SpellService.GetAllSpellsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading spells");
            errorMessage = "Не удалось загрузить список заклинаний. Пожалуйста, попробуйте позже.";
            spells = new List<Spell>();
        }

        currentPage = 1;
        expandedSpellId = null;
    }

    private void ApplyFilters()
    {
        currentPage = 1;
        StateHasChanged();
    }

    private void ResetFilters()
    {
        searchQuery = string.Empty;
        selectedTypeFilter = null;
        ApplyFilters();
    }

    private IQueryable<Spell> FilterSpells()
    {
        if (spells == null)
        {
            return Enumerable.Empty<Spell>().AsQueryable();
        }

        var query = spells.AsQueryable();

        if (!string.IsNullOrWhiteSpace(searchQuery))
        {
            var term = searchQuery.Trim();
            query = query.Where(spell =>
                (!string.IsNullOrWhiteSpace(spell.Name) && spell.Name.Contains(term, StringComparison.OrdinalIgnoreCase)) ||
                (!string.IsNullOrWhiteSpace(spell.SpellType) && spell.SpellType.Contains(term, StringComparison.OrdinalIgnoreCase)) ||
                (!string.IsNullOrWhiteSpace(spell.Description) && spell.Description.Contains(term, StringComparison.OrdinalIgnoreCase)) ||
                (spell.AlternativeNames.Any(name => name.Contains(term, StringComparison.OrdinalIgnoreCase))));
        }

        if (!string.IsNullOrWhiteSpace(selectedTypeFilter))
        {
            query = query.Where(spell => !string.IsNullOrWhiteSpace(spell.SpellType) &&
                                         spell.SpellType.Equals(selectedTypeFilter, StringComparison.OrdinalIgnoreCase));
        }

        query = sortField switch
        {
            nameof(Spell.SpellType) => sortAscending
                ? query.OrderBy(spell => spell.SpellType)
                : query.OrderByDescending(spell => spell.SpellType),
            nameof(Spell.Cost) => sortAscending
                ? query.OrderBy(spell => spell.Cost)
                : query.OrderByDescending(spell => spell.Cost),
            nameof(Spell.CastingTime) => sortAscending
                ? query.OrderBy(spell => spell.CastingTime)
                : query.OrderByDescending(spell => spell.CastingTime),
            _ => sortAscending
                ? query.OrderBy(spell => spell.Name)
                : query.OrderByDescending(spell => spell.Name)
        };

        return query;
    }

    private void ToggleSort(string field)
    {
        if (sortField == field)
        {
            sortAscending = !sortAscending;
        }
        else
        {
            sortField = field;
            sortAscending = true;
        }

        currentPage = 1;
    }

    private void GoToPage(int page)
    {
        if (page >= 1 && page <= totalPages)
        {
            currentPage = page;
        }
    }

    private void ShowAddModal()
    {
        isEditMode = false;
        editSpell = new Spell
        {
            Name = string.Empty,
            SpellType = SpellTypes.FirstOrDefault() ?? string.Empty,
            Cost = null,
            CastingTime = null,
            Description = string.Empty,
            AlternativeNames = new List<string>()
        };
        modalErrorMessage = null;
        showModal = true;
    }

    private void ShowEditModal(Spell spell)
    {
        isEditMode = true;
        editSpell = new Spell
        {
            Id = spell.Id,
            Name = spell.Name,
            SpellType = spell.SpellType,
            Cost = spell.Cost,
            CastingTime = spell.CastingTime,
            Description = spell.Description,
            AlternativeNames = spell.AlternativeNames?.ToList() ?? new List<string>()
        };
        modalErrorMessage = null;
        showModal = true;
    }

    private void HideModal()
    {
        showModal = false;
    }

    private async Task HandleValidSubmit()
    {
        modalErrorMessage = null;
        CleanSpell(editSpell);

        try
        {
            if (isEditMode)
            {
                var updated = await SpellService.UpdateSpellAsync(editSpell);
                if (!updated)
                {
                    modalErrorMessage = "Не удалось обновить заклинание.";
                    return;
                }
            }
            else
            {
                var added = await SpellService.AddSpellAsync(editSpell);
                if (!added)
                {
                    modalErrorMessage = "Не удалось добавить заклинание. Возможно, заклинание с таким названием уже существует.";
                    return;
                }
            }

            showModal = false;
            await LoadSpellsAsync();
            ApplyFilters();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving spell {SpellName}", editSpell.Name);
            modalErrorMessage = $"Не удалось сохранить заклинание: {ex.Message}";
        }
    }

    private void CleanSpell(Spell spell)
    {
        spell.Name = spell.Name.Trim();
        spell.SpellType = spell.SpellType?.Trim() ?? string.Empty;
        spell.Cost = string.IsNullOrWhiteSpace(spell.Cost) ? null : spell.Cost.Trim();
        spell.CastingTime = string.IsNullOrWhiteSpace(spell.CastingTime) ? null : spell.CastingTime.Trim();
        spell.Description = (spell.Description ?? string.Empty).Trim();
        spell.AlternativeNames = spell.AlternativeNames
            .Where(name => !string.IsNullOrWhiteSpace(name))
            .Select(name => name.Trim())
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private void ShowDeleteModal(Spell spell)
    {
        deleteSpell = spell;
        showDeleteModal = true;
    }

    private void HideDeleteModal()
    {
        showDeleteModal = false;
        deleteSpell = null;
    }

    private async Task ConfirmDelete()
    {
        if (deleteSpell == null)
        {
            return;
        }

        try
        {
            var deleted = await SpellService.DeleteSpellAsync(deleteSpell.Id);
            if (!deleted)
            {
                errorMessage = "Не удалось удалить заклинание.";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting spell {SpellId}", deleteSpell.Id);
            errorMessage = $"Не удалось удалить заклинание: {ex.Message}";
        }
        finally
        {
            showDeleteModal = false;
            deleteSpell = null;
            await LoadSpellsAsync();
            ApplyFilters();
        }
    }

    private void ToggleSpellDetails(Spell spell)
    {
        expandedSpellId = expandedSpellId == spell.Id ? null : spell.Id;
    }
}
